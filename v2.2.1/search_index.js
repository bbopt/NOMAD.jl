var documenterSearchIndex = {"docs":
[{"location":"nomadProblem/#Parameters-setting","page":"Parameters","title":"Parameters setting","text":"","category":"section"},{"location":"nomadProblem/","page":"Parameters","title":"Parameters","text":"The settings of a NOMAD optimization process must be entered in an object of the type described below.","category":"page"},{"location":"nomadProblem/","page":"Parameters","title":"Parameters","text":"NomadProblem","category":"page"},{"location":"nomadProblem/#NOMAD.NomadProblem","page":"Parameters","title":"NOMAD.NomadProblem","text":"NomadProblem(nb_inputs::Int, nb_outputs::Int, output_types::Vector{String}, eval_bb::Function;\n             input_types::Vector{String} = [\"R\" for i in 1:nb_inputs],\n             granularity::Vector{Float64} = zeros(Float64, nb_inputs),\n             lower_bound::Vector{Float64} = -Inf * ones(Float64, nb_inputs),\n             upper_bound::Vector{Float64} = Inf * ones(Float64, nb_inputs),\n             A::Union{Nothing, Matrix{Float64}} = nothing,\n             b::Union{Nothing, Vector{Float64}} = nothing,\n             min_mesh_size::Vector{Float64} = zeros(Float64, nb_inputs),\n             b::Union{Nothing, Vector{Float64}} = nothing,\n             initial_mesh_size::Vector{Float64} = Float64[])\n\nStruct containing the main information needed to solve a blackbox problem by the Nomad Software.\n\nAttributes:\n\nnb_inputs::Int:\n\nNumber of inputs of the blackbox. Is required to be > 0.\n\nNo default, needs to be set.\n\nnb_outputs::Int:\n\nNumber of outputs of the blackbox. Is required to be > 0.\n\nNo default, needs to be set.\n\noutput_types::Vector{String}:\n\nA vector containing String objects that define the types of outputs returned by eval_bb (the order is important) :\n\nString Output type\n\"OBJ\" objective value to be minimized\n\"PB\" progressive barrier constraint\n\"EB\" extreme barrier constraint\n\nNo default value, needs to be set.\n\neval_bb::Function:\n\nA function of the form :\n\n    (success, count_eval, bb_outputs) = eval(x::Vector{Float64})\n\nbb_outputs being a Vector{Float64} containing the values of objective function and constraints for a given input vector x. NOMAD will seek to minimize the objective function and keeping constraints inferior to 0.\n\nsuccess is a Bool set to false if the evaluation failed.\n\ncount_eval is a Bool equal to true if the blackbox evaluation counting has to be incremented.\n\ninput_types::Vector{String}:\n\nA vector containing String objects that define the types of inputs to be given to eval_bb (the order is important) :\n\nString Input type\n\"R\" Real/Continuous\n\"B\" Binary\n\"I\" Integer\n\nall R by default.\n\ngranularity::Vector{Float64}:\n\nThe granularity of input variables, that is to say the minimum variation authorized for these variables. A granularity of 0 corresponds to a real variable.\n\nBy default, 0 for real variables, 1 for integer and binary ones.\n\nmin_mesh_size::Vector{Float64}:\n\nThe minimum mesh size to reach allowed by each input variable. When a variable decreases below the threshold, the algorithm stops.\n\nBy default, 0 (which corresponds to the Nomad software tolerance).\n\ninitial_mesh_size::Vector{Float64}:\n\nThe initial mesh size set for each input variable. Can be adjusted if the granularity is set.\n\nEmpty by default.\n\nlower_bound::Vector{Float64}:\n\nLower bound for each coordinate of the blackbox input. -Inf * ones(Float64, nb_inputs), by default.\n\nupper_bound::Vector{Float64}:\n\nUpper bound for each coordinate of the blackbox input.\n\nInf * ones(Float64, nb_inputs), by default.\n\nA::Union{Nothing, Matrix{Float64}}:\n\nMatrix A in the potential equality constraints Ax = b, where x are the inputs of the blackbox. A must have more columns than lines. If defined, the granularity parameters should be set to default value, i.e. 0.\n\nnothing, by default.\n\nb::Union{Nothing, Vector{Float64}}:\n\nVector b in the potential equality constraints Ax=b, where x are the inputs of the blackbox. b must be defined when A is defined. In this case, dimensions must match.\n\nnothing, by default.\n\noptions::NomadOptions\n\nNomad options that can be set before running the optimization process.\n\n-> max_cache_size::Int:\n\nMaximum number of points stored in the cache.\n\nInf by default.\n\n-> display_degree::Int:\n\nInteger between 0 and 3 that sets the level of display.\n\n-> display_all_eval::Bool:\n\nIf false, only evaluations that allow to improve the current state are displayed.\n\nfalse by default.\n\n-> display_infeasible::Bool:\n\nIf true, display best infeasible values reached by Nomad until the current step.\n\nfalse by default.\n\n-> display_unsuccessful::Bool:\n\nIf true, display evaluations that are unsuccessful.\n\nfalse by default.\n\n-> display_stats::Bool:\n\nA vector containing String objects that define the statistics to display when the algorithm is running.\n\nString Display Statistics Arguments\n\"BBE\" Blackbox evaluations\n\"BBO\" Blackbox outputs\n\"CACHE_HITS\" Cache hits\n\"CACHE_SIZE\" Cache size\n\"CONS_H\" Infeasibility (h) value\n\"EVAL\" Evaluations (includes cache hits)\n\"FEAS_BBE\" Feasible blackbox evaluations\n\"GEN_STEP\" Name of the step that generated\n this point to evaluate\n\"H_MAX\" Max infeasibility (h) acceptable\n\"INF_BBE\" Infeasible blackbox evaluations\n\"ITER_NUM\" Iteration number in which this\n evaluation was done\n\"MESH_INDEX\" Mesh index\n\"OBJ\" Objective function value\n\"PHASE_ONE_SUCC\" Success evaluations during phase one\n phase\n\"SGTE\" Number of surrogate evaluations since\n last reset\n\"SOL\" Current feasible iterate (displayed\n in ())\n\"SUCCESS_TYPE\" Success type for this evaluation,\n compared with the frame center\n\"TIME\" Real time in seconds\n\"TOTAL_SGTE\" Total number of surrogate evaluations\n\nEmpty by default.\n\n-> max_bb_eval::Int:\n\nMaximum of calls to eval_bb allowed. Must be positive.\n\n20000 by default.\n\n-> max_sgte_eval::Int:\n\nMaximum of calls to surrogate models for each optimization of surrogate problem allowed. Must be positive.\n\n1000 by default.\n\n-> opportunistic_eval::Bool\n\nIf true, the algorithm performs an opportunistic strategy at each iteration.\n\ntrue by default.\n\n-> use_cache::Bool:\n\nIf true, the algorithm only evaluates one time a given input. Avoids to recalculate a blackbox value if this last one has already be computed.\n\ntrue by default.\n\n-> random_eval_sort::Bool:\n\nIf true, trial points are randomly shuffled before being evaluated.\n\nfalse by default.\n\n-> lh_search::Tuple{Int, Int}:\n\nLH search parameters.\n\nlh_search[1] is the lh_search_init parameter, i.e. the number of initial search points performed with Latin-Hypercube method.\n\n0 by default.\n\nlh_search[2] is the  lh_search_iter parameter, i.e. the number of search points performed at each iteration with Latin-Hypercube method.\n\n0 by default.\n\n-> quad_model_search::Bool:\n\nIf true, the algorithm executes a quadratic model search strategy at each iteration. Deactivated when the number of variables is greater than 50.\n\ntrue by default.\n\n-> sgtelib_search::Bool:\n\nIf true, the algorithm executes a model search strategy at each iteration. Deactivated when the number of variables is greater than 50.\n\nfalse by default.\n\n-> sgtelib_model_trials::Int:\n\nMaximum number of model search steps by iteration to try, before going to the poll step. Must be positive.\n\n1 by default.\n\n-> speculative_search::Bool:\n\nIf true, the algorithm executes a speculative search strategy at each iteration.\n\ntrue by default.\n\n-> speculative_search_max::Int:\n\nNumber of points to generate using the Mads speculative search (when opportunistic strategy). Must be positive.\n\n1 by default.\n\n-> nm_search::Bool:\n\nIf true, the algorithm executes a speculative search strategy at each iteration.\n\ntrue by default.\n\n-> nm_search_stop_on_success::Bool:\n\nIf true, the nm_search strategy stops opportunistically (as soon as a better point is found).\n\nfalse by default.\n\n-> max_time::Union{Nothing, Int}:\n\nIf defined, maximum clock time (in seconds) execution of the algorithm.\n\nfalse by default.\n\n-> linear_converter::String:\n\nThe type of converter to deal with linear equality constraints. Can be SVD or QR.\n\nSVD by default.\n\n-> linear_constraints_atol::Float64:\n\nThe tolerance accuracy that x0 must satisfy, when there are linear equality constraints, i.e. A * x0 = b.\n\n0 by default.\n\n\n\n\n\n","category":"type"},{"location":"nomadResults/#Results","page":"Results","title":"Results","text":"","category":"section"},{"location":"nomadResults/","page":"Results","title":"Results","text":"Main results from a NOMAD optimization process are stored in an object of the type described below.","category":"page"},{"location":"nomadResults/","page":"Results","title":"Results","text":"nomadResults","category":"page"},{"location":"surrogates/#Surrogates","page":"Surrogates","title":"Surrogates","text":"","category":"section"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"The current version of NOMAD.jl supports use of static surrogates which are not updated during the run and which are provided by the user. A surrogate provides approximations of the black box outputs and is typically less time-consuming to evaluate. Hence, their use allows to speed up the optimization process.","category":"page"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"Such surrogates can be provided to NOMAD.jl as simple Function objects of the following form :","category":"page"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"(success, count_eval, sgte_outputs) = surrogate(x :: Vector{Number})","category":"page"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"The surrogate needs to return the same number of outputs as the function eval(x), with the same types and in the same order. Just like for eval(x), count_eval is a Bool determining if the evaluation has to be taken into account, and success is a Bool equal to false if the evaluation failed.","category":"page"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"You can directly provide it to the function nomad() as an optional argument. The corresponding method is :","category":"page"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"nomad(eval :: Function, param :: nomadParameters; surrogate :: Function)","category":"page"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"which returns an object of type nomadResults.","category":"page"},{"location":"surrogates/","page":"Surrogates","title":"Surrogates","text":"The cost of the surrogate can be set via the attribute sgte_cost of the nomadParameters provided to nomad(). More precisely, sgte_cost is the number of surrogate evaluations costing as much as one black box evaluation. If set to 0, a surrogate evaluation is considered as free. It is set to 0 by default.","category":"page"},{"location":"run_nomad/#Run-the-optimization","page":"Run Optimization","title":"Run the optimization","text":"","category":"section"},{"location":"run_nomad/","page":"Run Optimization","title":"Run Optimization","text":"A NOMAD optimization process can be run by using the solve() method described below.","category":"page"},{"location":"run_nomad/","page":"Run Optimization","title":"Run Optimization","text":"solve(p :: NomadProblem, x0 :: Vector{Float64})","category":"page"},{"location":"run_nomad/#NOMAD.solve-Tuple{NomadProblem, Vector{Float64}}","page":"Run Optimization","title":"NOMAD.solve","text":"solve(p::NomadProblem, x0::Vector{Float64})\n\n-> Run NOMAD with settings defined by NomadProblem p from starting point x0.\n\n-> Display stats from NOMAD in the REPL.\n\n-> Return a NamedTuple that contains info about the run.\n\nArguments:\n\np::NomadProblem\n\nThe problem to solve.\n\nx0::Vector{Float64}\n\nThe starting point. Must satisfy lb <= x0 <= ub where lb and ub are respectively the lower and upper bounds of the NomadProblem p. When A and b are defined, it must satisfy A * x0 = b.\n\nExample:\n\nusing NOMAD\n\nfunction eval_fct(x)\n    f = x[1]^2 + x[2]^2\n    c = 1 - x[1]\n    success = true\n    count_eval = true\n    bb_outputs = [f,c]\n    return (success, count_eval, bb_outputs)\nend\n\n# creation of a blackbox of dimensions 2*2 with one objective (\"OBJ\")\n# and a constraint treated with the extreme barrier approach (\"EB\")\np = NomadProblem(2, 2, [\"OBJ\", \"EB\"], eval_fct)\n\n# solve problem starting from the point [5.0;5.0]\nresult = solve(p, [5.0;5.0])\n\n\n\n\n\n","category":"method"},{"location":"nomadParameters/#Parameters-setting","page":"Parameters setting","title":"Parameters setting","text":"","category":"section"},{"location":"nomadParameters/","page":"Parameters setting","title":"Parameters setting","text":"The settings of a NOMAD optimization process must be entered in an object of the type described below.","category":"page"},{"location":"nomadParameters/","page":"Parameters setting","title":"Parameters setting","text":"nomadParameters","category":"page"},{"location":"#Home","page":"Home","title":"NOMAD.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia interface for NOMAD, which is a C++ implementation of the Mesh Adaptive Direct Search algorithm (MADS), designed for difficult blackbox optimization problems. These problems occur when the functions defining the objective and constraints are the result of costly computer simulations.","category":"page"},{"location":"#Type-of-problems-treated","page":"Home","title":"Type of problems treated","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NOMAD allows to deal with optimization problems of the form :","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayrrcll\n  (BB)    \n  displaystyle min_x  f(x)\n  st\n                  c_i(x)  leq 0      forall i = 1  m\n   ell_j leq  x_j   leq u_j  forall j = 1  n\nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"where fmathbbR^nrightarrowmathbbR, cmathbbR^nrightarrowmathbbR^m, and ell_j u_j in mathbbRcuppminfty for j = 1dotsn.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions f and c_i are typically blackbox functions of which evaluations require computer simulation.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, one needs to declare a blackbox bb(x :: Vector{Float64}) that returns two booleans and a Vector{Float64} that contains the objective function and constraints evaluated for x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function bb(x)\n  f = x[1]^2 + x[2]^2\n  c = 1 - x[1]\n  success = true\n  count_eval = true\n  bb_outputs = [f; c]\n  return (success, count_eval, bb_outputs)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"success is a Bool that should be set to false if the evaluation failed. count_eval is a Bool that should be equal to true if the black box evaluation counting has to be incremented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To optimize this blackbox, an object of type NomadProblem has to be created. It takes as arguments the number of inputs, the number of outputs and the type of the outputs of the blackbox, and the blackbox. Other options can be passed to a NomadProblem object.","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = NomadProblem(2, 2, [\"OBJ\"; \"EB\"], bb,\n                lower_bound=[-5.0;-5.0],\n                upper_bound=[5.0;5.0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, first element of bb_outputs is the objective function (f), second is a constraint treated with the Extreme Barrier method (c). In this example, lower and upper bounds have been added but it is not compulsory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now the function solve() can be called with these arguments to launch a NOMAD optimization run.","category":"page"},{"location":"","page":"Home","title":"Home","text":"result = solve(p, [3.0;3.0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is returned by the solve function is a NamedTuple containing solutions and corresponding blackbox values found by the Nomad solver.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Moustache-problem","page":"Tutorial","title":"Moustache problem","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginarrayrl\n  (BB)    \n  displaystyle max_xy  x\n  st\n   y in I(x)\nendarray","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The objective is to maximise f(x y) = x with f not defined outside of a tight ribbon. At a given x, the interval of the admissible y values is denoted I(x) = g(x) - varepsilon(x), g(x) + varepsilon(x), with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"g(x) = -(cos(x) + 01) sin(x) + 2 textand varepsilon(x) = 005 + 005 Bigg(1 + dfrac11 + x - 11Bigg)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can rewrite the problem such that it can be solved with NOMAD. We choose as starting point (0 2) and restrict the domain such that x in 020 and y in 0 4.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginarrayrrcll\n  (BB)    \n  displaystyle - min_x in mathbbR^2  -x_1\n  st\n                  g(x_1) - varepsilon(x_1) - x_2  leq 0      \n                  x_2 - g(x_1) + varepsilon(x_1)  leq 0      \n          0 leq  x_1                              leq 20     \n          0 leq  x_2                              leq 4      \nendarray","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NOMAD\n\n# Objective\nfunction f(x)\n  return -x[1]\nend\n\n# Constraints\nfunction c(x)\n  g = -(abs(cos(x[1])) + 0.1) * sin(x[1]) + 2\n  ε = 0.05 + 0.05 * (1 - 1 / (1 + abs(x[1] - 11)))\n  constraints = [g - ε - x[2]; x[2] - g - ε]\n  return constraints\nend\n\n# Evaluator\nfunction bb(x)\n  bb_outputs = [f(x); c(x)]\n  success = true\n  count_eval = true\n  return (success, count_eval, bb_outputs)\nend\n\n# Define Nomad Problem\np = NomadProblem(2, 3, [\"OBJ\"; \"EB\"; \"EB\"], bb,\n                lower_bound=[0.0;0.0],\n                upper_bound=[20.0;4.0])\n\n# Fix some options\np.options.max_bb_eval = 1000 # total number of evaluations\np.options.display_stats = [\"BBE\", \"EVAL\", \"SOL\", \"OBJ\", \"CONS_H\"] # some display options\n\n# Solution\nresult = solve(p, [0.0;2.0])\nprintln(\"Solution: \", result.x_best_feas)","category":"page"},{"location":"tutorial/#Linear-equality-constraints","page":"Tutorial","title":"Linear equality constraints","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is also possible to define linear equality constraints in a NomadProblem structure. NOMAD handles differently these constraints and solves the original problem on a reduced subspace. For more details we refer the reader to:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"C. Audet, S. Le Digabel and M. Peyrega, Linear equalities in blackbox optimization. Computational Optimization and Applications, 61(1), 1-23, May 2015.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We consider the following example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginarrayrl\n  (BB)    \n  displaystyle min_x in mathbbR^5  (x_1 -1)^2 + (x_2 - x_3)^2 + (x_4 - x_5)^2\n  st\n   x_1 + x_2 + x_3 + x_4 + x_5 = 5 \n   x_3 -2 x_4 - 2 x_5 = -3\n   -10 leq x_1 x_2 x_3 x_4 x_5 leq 10\nendarray","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This problem can be solved by Nomad the following way:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NOMAD\n\n# blackbox\nfunction bb(x)\n  f = (x[1]- 1)^2 * (x[2] - x[3])^2 + (x[4] - x[5])^2\n  bb_outputs = [f]\n  success = true\n  count_eval = true\n  return (success, count_eval, bb_outputs)\nend\n\n# linear equality constraints\nA = [1.0 1.0 1.0 1.0 1.0;\n     0.0 0.0 1.0 -2.0 -2.0]\nb = [5.0; -3.0]\n\n# Define blackbox\np = NomadProblem(5, 1, [\"OBJ\"], # the equality constraints are not counted in the outputs of the blackbox\n                 bb,\n                 lower_bound = -10.0 * ones(5),\n                 upper_bound = 10.0 * ones(5),\n                 A = A, b = b)\n\n# Fix some options\np.options.max_bb_eval = 500\n\n# Define starting points. It must satisfy A x = b.\nx0 = [0.57186958424864897665429452899843;\n      4.9971472653643420613889247761108;\n      -1.3793445664086618762667058035731;\n      1.0403394252630473459930726676248;\n      -0.2300117084673765077695861691609]\n\n# Solution\nresult = solve(p, x0)\nprintln(\"Solution: \", result.x_best_feas)\nprintln(\"Satisfy Ax = b: \", A * result.x_best_feas ≈ b)\nprintln(\"And inside bound constraints: \", all(-10.0 .<= result.x_best_feas .<= 10.0))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The reader can take a look at the test folder for more complex examples.","category":"page"}]
}
