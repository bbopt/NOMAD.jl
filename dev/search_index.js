var documenterSearchIndex = {"docs":
[{"location":"nomadProblem/#Parameters-setting","page":"Parameters","title":"Parameters setting","text":"The settings of a NOMAD optimization process must be entered in an object of the type described below.","category":"section"},{"location":"nomadProblem/#NOMAD.NomadProblem","page":"Parameters","title":"NOMAD.NomadProblem","text":"NomadProblem(nb_inputs::Int, nb_outputs::Int, output_types::Vector{String}, eval_bb::Function;\n             input_types::Vector{String} = [\"R\" for i in 1:nb_inputs],\n             granularity::Vector{Float64} = zeros(Float64, nb_inputs),\n             lower_bound::Vector{Float64} = -Inf * ones(Float64, nb_inputs),\n             upper_bound::Vector{Float64} = Inf * ones(Float64, nb_inputs),\n             A::Union{Nothing, Matrix{Float64}} = nothing,\n             b::Union{Nothing, Vector{Float64}} = nothing,\n             min_mesh_size::Vector{Float64} = zeros(Float64, nb_inputs),\n             b::Union{Nothing, Vector{Float64}} = nothing,\n             initial_mesh_size::Vector{Float64} = Float64[])\n\nStruct containing the main information needed to solve a blackbox problem by the Nomad Software.\n\nAttributes:\n\nnb_inputs::Int:\n\nNumber of inputs of the blackbox. Is required to be > 0.\n\nNo default, needs to be set.\n\nnb_outputs::Int:\n\nNumber of outputs of the blackbox. Is required to be > 0.\n\nNo default, needs to be set.\n\noutput_types::Vector{String}:\n\nA vector containing String objects that define the types of outputs returned by eval_bb (the order is important) :\n\nString Output type\n\"OBJ\" objective value to be minimized\n\"PB\" progressive barrier constraint\n\"EB\" extreme barrier constraint\n\nNo default value, needs to be set.\n\neval_bb::Function:\n\nA function of the form :\n\n    (success, count_eval, bb_outputs) = eval(x::Vector{Float64})\n\nbb_outputs being a Vector{Float64} containing the values of objective function and constraints for a given input vector x. NOMAD will seek to minimize the objective function and keeping constraints inferior to 0.\n\nsuccess is a Bool set to false if the evaluation failed.\n\ncount_eval is a Bool equal to true if the blackbox evaluation counting has to be incremented.\n\ninput_types::Vector{String}:\n\nA vector containing String objects that define the types of inputs to be given to eval_bb (the order is important) :\n\nString Input type\n\"R\" Real/Continuous\n\"B\" Binary\n\"I\" Integer\n\nall R by default.\n\ngranularity::Vector{Float64}:\n\nThe granularity of input variables, that is to say the minimum variation authorized for these variables. A granularity of 0 corresponds to a real variable.\n\nBy default, 0 for real variables, 1 for integer and binary ones.\n\nmin_mesh_size::Vector{Float64}:\n\nThe minimum mesh size to reach allowed by each input variable. When a variable decreases below the threshold, the algorithm stops.\n\nBy default, 0 (which corresponds to the Nomad software tolerance).\n\ninitial_mesh_size::Vector{Float64}:\n\nThe initial mesh size set for each input variable. Can be adjusted if the granularity is set.\n\nEmpty by default.\n\nlower_bound::Vector{Float64}:\n\nLower bound for each coordinate of the blackbox input. -Inf * ones(Float64, nb_inputs), by default.\n\nupper_bound::Vector{Float64}:\n\nUpper bound for each coordinate of the blackbox input.\n\nInf * ones(Float64, nb_inputs), by default.\n\nA::Union{Nothing, Matrix{Float64}}:\n\nMatrix A in the potential equality constraints Ax = b, where x are the inputs of the blackbox. A must have more columns than lines. If defined, the granularity parameters should be set to default value, i.e. 0.\n\nnothing, by default.\n\nb::Union{Nothing, Vector{Float64}}:\n\nVector b in the potential equality constraints Ax=b, where x are the inputs of the blackbox. b must be defined when A is defined. In this case, dimensions must match.\n\nnothing, by default.\n\noptions::NomadOptions\n\nNomad options that can be set before running the optimization process.\n\n-> cache_size_max::Int\n\nMaximum number of points stored in the cache.\n\nInf` by default.\n\n-> display_degree::Int:\n\nInteger between 0 and 3 that sets the level of display.\n\n-> display_all_eval::Bool:\n\nIf false, only evaluations that allow to improve the current state are displayed.\n\nfalse by default.\n\n-> display_infeasible::Bool:\n\nIf true, display best infeasible values reached by Nomad until the current step.\n\nfalse by default.\n\n-> display_unsuccessful::Bool:\n\nIf true, display evaluations that are unsuccessful.\n\nfalse by default.\n\n-> display_stats::Bool:\n\nA vector containing String objects that define the statistics to display when the algorithm is running.\n\nString Display Statistics Arguments\n\"BBE\" Blackbox evaluations\n\"BBO\" Blackbox outputs\n\"CACHE_HITS\" Cache hits\n\"CACHE_SIZE\" Cache size\n\"CONS_H\" Infeasibility (h) value\n\"EVAL\" Evaluations (includes cache hits)\n\"FEAS_BBE\" Feasible blackbox evaluations\n\"GEN_STEP\" Name of the step that generated\n this point to evaluate\n\"H_MAX\" Max infeasibility (h) acceptable\n\"INF_BBE\" Infeasible blackbox evaluations\n\"ITER_NUM\" Iteration number in which this\n evaluation was done\n\"MESH_INDEX\" Mesh index\n\"OBJ\" Objective function value\n\"PHASE_ONE_SUCC\" Success evaluations during phase one\n phase\n\"SGTE\" Number of surrogate evaluations since\n last reset\n\"SOL\" Current feasible iterate (displayed\n in ())\n\"SUCCESS_TYPE\" Success type for this evaluation,\n compared with the frame center\n\"TIME\" Real time in seconds\n\"TOTAL_SGTE\" Total number of surrogate evaluations\n\nEmpty by default.\n\n-> max_bb_eval::Int:\n\nMaximum of calls to eval_bb allowed. Must be positive.\n\n20000 by default.\n\n-> sgtelib_model_max_eval::Int:\n\nMaximum number of calls to surrogate models for each optimization of surrogate problem allowed. Must be positive.\n\n1000 by default.\n\n-> eval_opportunistic::Bool\n\nIf true, the algorithm performs an opportunistic strategy at each iteration.\n\ntrue by default.\n\n-> eval_use_cache::Bool:\n\nIf true, the algorithm only evaluates one time a given input. Avoids to recalculate a blackbox value if this last one has already be computed.\n\ntrue by default.\n\n-> eval_sort_type::String:\n\nOrder points before evaluation according to one of the following strategies\n\nString Eval Sort strategy\n\"DIR_LAST_SUCCESS\" Use last success direction\n\"LEXICOGRAPHICAL\" Use lexicographical ordering (coordinates)\n\"RANDOM\" Do not sort\n\"QUADRATIC_MODEL\" Use quadratic models\n\n\"QUADRATIC_MODEL\" by default.\n\n-> h_max_0::Float64:\n\nInitial value of the barrier threshold for progressive barrier (PB). Must be positive.\n\nInf by default.\n\n-> direction_type::String:\n\nDirection type for Mads poll. The following direction types are available\n\nString Direction type\n\"ORTHO 2N\" OrthoMads with 2n directions\n\"ORTHO N+1 NEG\" OrthoMads with n+1 directions. The (n+1)e\n is the negative sum of the n first.\n\"ORTHO N+1 QUAD\" OrthoMads with n+1 directions. The (n+1)e\n is found by solving a quadratic subproblem\n\"N+1 UNI\" n+1 uniform distribution of directions\n\"SINGLE\" Single direction\n\"DOUBLE\" Two opposed directions\n\nEmpty by default (the NOMAD software adopts a \"ORTHO N+1 QUAD\" strategy by default).\n\n-> direction_type_secondary_poll::String\n\nDirection type for secondary Mads poll for the progressive barrier (PB). The same direction types than direction_type are available.\n\nEmpty by default (by default, the NOMAD software adopts a \"DOUBLE\" strategy if direction_type is set to \"ORTHO 2N\" or \"ORTHO N+1\" or a \"SINGLE\" strategy otherwise).\n\n-> anisotropic_mesh::Bool:\n\nUse anisotropic mesh to generate directions for MADS.\n\ntrue by default.\n\n-> anisotropy_factor::Float64:\n\nThe MADS anisotropy factor for mesh size change. Must be strictly positive.\n\n0.1 by default.\n\n-> lh_search::Tuple{Int, Int}:\n\nLH search parameters.\n\nlh_search[1] is the lh_search_init parameter, i.e. the number of initial search points performed with Latin-Hypercube method.\n\n0 by default.\n\nlh_search[2] is the  lh_search_iter parameter, i.e. the number of search points performed at each iteration with Latin-Hypercube method.\n\n0 by default.\n\n-> quad_model_search::Bool:\n\nIf true, the algorithm executes a quadratic model search strategy at each iteration. Deactivated when the number of variables is greater than 50.\n\ntrue by default.\n\n-> sgtelib_model_search::Bool:\n\nIf true, the algorithm executes a model search strategy using Sgtelib at each iteration. Deactivated when the number of variables is greater than 50.\n\nfalse by default.\n\n-> simple_line_search::Bool:\n\nIf true, the algorithm executes a line search strategy at each iteration. Does not work with speculative search.\n\nfalse by default.\n\n-> speculative_search::Bool:\n\nIf true, the algorithm executes a speculative search strategy at each iteration.\n\ntrue by default.\n\n-> speculative_search_base_factor::Float64:\n\nThe factor distance to the current incumbent for the MADS speculative search. Must be strictly superior to 1.\n\n4.0 by default.\n\n-> speculative_search_max::Int:\n\nNumber of points to generate using the Mads speculative search (when opportunistic strategy). Must be positive.\n\n1 by default.\n\n-> nm_search::Bool:\n\nIf true, the algorithm executes a Nelder-Mead search strategy at each iteration.\n\ntrue by default.\n\n-> nm_delta_e::Float64:\n\nThe expansion parameter of the Nelder-Mead search. Must be > 1.\n\n2.0 by default.\n\n-> nm_delta_ic::Float64:\n\nThe inside contraction parameter of the Nelder-Mead search. Must be strictly comprised between -1 and 0.\n\n-0.5 by default.\n\n-> nm_delta_oc::Float64:\n\nThe outside contraction parameter of the Nelder-Mead search. Must be strictly comprised between 0 and 1.\n\n0.5 by default.\n\n-> nm_gamma::Float64:\n\nThe shrink parameter of the Nelder-Mead search. Must be strictly comprised between 0 and 1.\n\n0.5 by default.\n\n-> nm_search_rank_eps::Float64:\n\nThe tolerance parameter on the rank of the initial simplex built in the Nelder-Mead search. Must be strictly positive.\n\n0.01 by default.\n\n-> nm_search_max_trial_pts_nfactor::Int:\n\nNelder-Mead search stops when nm_search_max_trial_pts_nfactor * n evaluations are reached, n being the number of variables of the problem.\n\n80 by default.\n\n-> nm_search_stop_on_success::Bool:\n\nIf true, the nm_search strategy stops opportunistically (as soon as a better point is found).\n\nfalse by default.\n\n-> vns_mads_search::Bool:\n\nIf true, the algorithm executes a Variable Neighbourhoold search strategy at each iteration.\n\nfalse by default.\n\n-> vns_mads_search_max_trial_pts_nfactor::Int:\n\nThe VNS strategy, when triggered, stops when this parameter is reached.\n\n100 by default.\n\n-> vns_mads_search_trigger::Float64\n\nMaximum desired ratio of VNS blackbox evaluations over the total number of blackbox evaluations. When 0, the VNS search is never executed; when 1, a search is launched at each iteration.\n\n0.75 by default.\n\n-> vnsmart_mads_search::Bool:\n\nIf true, the algorithm executes a Variable Neighbourhoold search strategy under condition of consecutive fails.\n\nfalse by default.\n\n-> vnsmart_mads_search_threshold::Int:\n\nThe Variable Neighbourhoold search (Smart) strategy activates when this threshold is reached.\n\n3 by default.\n\n-> stop_if_feasible::Bool:\n\nStop algorithm as soon as a feasible solution is found.\n\nfalse by default.\n\n-> stop_if_phase_one_solution::Bool:\n\nStop algorithm once a phase one solution is obtained.\n\nfalse by default.\n\n-> Multiobjective optimization. NOMAD activates multiobjective optimization when the number of objectives is greater than 1. In this case, all search strategies, excepted the speculative search, the NM search and the Quadratic model search are deactivated.\n\n-> dmultimads_nm_strategy::String:\n\nNelder-Mead search strategies for DMultiMads (multiobjective optimization).\n\nString DMultiMads NM search\n\"DOM\" Dominance Move strategy\n\"MULTI\" MultiMads strategy\n\nDOM by default.\n\n-> dmultimads_quad_model_strategy::String:\n\nQuadratic model search strategies for DMultiMads (multiobjective optimization).\n\nString DMultiMads NM search\n\"DMS\" DirectMultiSearch strategy\n\"DOM\" Dominance Move strategy\n\"MULTI\" MultiMads strategy\n\nMULTI by default.\n\n-> dmultimads_select_incumbent_threshold::Int:\n\nA parameter that controls the number of points that can be chosen as current incumbents for DMultiMads (multiobjective optimization). The bigger the less restrictive the choice.\n\n1 by default.\n\n-> max_time::Union{Nothing, Int}:\n\nIf defined, maximum clock time (in seconds) execution of the algorithm.\n\nfalse by default.\n\n-> linear_converter::String:\n\nThe type of converter to deal with linear equality constraints. Can be SVD or QR.\n\nSVD by default.\n\n-> linear_constraints_atol::Float64:\n\nThe tolerance accuracy that x0 must satisfy, when there are linear equality constraints, i.e. A * x0 = b.\n\n0 by default.\n\n\n\n\n\n","category":"type"},{"location":"run_nomad/#Run-the-optimization","page":"Run Optimization","title":"Run the optimization","text":"A NOMAD optimization process can be run by using the solve() method described below.","category":"section"},{"location":"run_nomad/#NOMAD.solve-Tuple{NomadProblem, Vector{Float64}}","page":"Run Optimization","title":"NOMAD.solve","text":"solve(p::NomadProblem, x0::Vector{Float64})\n\n-> Run NOMAD with settings defined by NomadProblem p from starting point x0.\n\n-> Display stats from NOMAD in the REPL.\n\n-> Return a NamedTuple that contains info about the run, specifically:\n\nstatus::Int:\n\nValue Meaning\n1 Objective target reached OR Mads converged\n (mesh criterion) to a feasible point (true problem).\n0 At least one feasible point obtained and evaluation\n budget spent or max iteration (user option) reached.\n-1 Mads mesh converged but no feasible point obtained\n (only infeasible) for the true problem.\n-2 No feasible point obtained (only infeasible) and\n evaluation budget (single bb or block of bb) spent\n or max iteration (user option) reached.\n-3 Initial point failed to evaluate.\n-4 Time limit reached (user option).\n-5 CTRL-C or user stopped (callback function).\n-6 Stop on feasible point (user option).\n-7 Wrong parameters.\n-8 Something has gone wrong with the optimization.\n\nAll the other fields are populated if status ∉ [-3, -7, -8].\n\nfeasible::Bool:\n\nIndicates if the set of solutions returned by the algorithm is feasible.\n\nArguments:\n\np::NomadProblem\n\nThe problem to solve.\n\nx0::Vector{Float64}\n\nThe starting point. Must satisfy lb <= x0 <= ub where lb and ub are respectively the lower and upper bounds of the NomadProblem p. When A and b are defined, it must satisfy A * x0 = b.\n\nExample:\n\nusing NOMAD\n\nfunction eval_fct(x)\n    f = x[1]^2 + x[2]^2\n    c = 1 - x[1]\n    success = true\n    count_eval = true\n    bb_outputs = [f,c]\n    return (success, count_eval, bb_outputs)\nend\n\n# creation of a blackbox of dimensions 2*2 with one objective (\"OBJ\")\n# and a constraint treated with the extreme barrier approach (\"EB\")\np = NomadProblem(2, 2, [\"OBJ\", \"EB\"], eval_fct)\n\n# solve problem starting from the point [5.0;5.0]\nstats = solve(p, [5.0;5.0])\n\n\n\n\n\n","category":"method"},{"location":"#[NOMAD.jl-documentation]-(@id-Home)","page":"Home","title":"[NOMAD.jl documentation] (@id Home)","text":"This package provides a Julia interface for NOMAD, which is a C++ implementation of the Mesh Adaptive Direct Search algorithm (MADS), designed for difficult blackbox optimization problems. These problems occur when the functions defining the objective and constraints are the result of costly computer simulations.","category":"section"},{"location":"#Type-of-problems-treated","page":"Home","title":"Type of problems treated","text":"NOMAD allows to deal with optimization problems of the form :\n\nbeginarrayrrcll\n  (BB)    \n  displaystyle min_x  f(x)\n  st\n                  c_i(x)  leq 0      forall i = 1  m\n   ell_j leq  x_j   leq u_j  forall j = 1  n\nendarray\n\nwhere fmathbbR^nrightarrowmathbbR, cmathbbR^nrightarrowmathbbR^m, and ell_j u_j in mathbbRcuppminfty for j = 1dotsn.\n\nThe functions f and c_i are typically blackbox functions of which evaluations require computer simulation.","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"First, one needs to declare a blackbox bb(x :: Vector{Float64}) that returns two booleans and a Vector{Float64} that contains the objective function and constraints evaluated for x.\n\nfunction bb(x)\n  f = x[1]^2 + x[2]^2\n  c = 1 - x[1]\n  success = true\n  count_eval = true\n  bb_outputs = [f; c]\n  return (success, count_eval, bb_outputs)\nend\n\nsuccess is a Bool that should be set to false if the evaluation failed. count_eval is a Bool that should be equal to true if the black box evaluation counting has to be incremented.\n\nTo optimize this blackbox, an object of type NomadProblem has to be created. It takes as arguments the number of inputs, the number of outputs and the type of the outputs of the blackbox, and the blackbox. Other options can be passed to a NomadProblem object.\n\np = NomadProblem(2, 2, [\"OBJ\"; \"EB\"], bb,\n                lower_bound=[-5.0;-5.0],\n                upper_bound=[5.0;5.0])\n\nHere, first element of bb_outputs is the objective function (f), second is a constraint treated with the Extreme Barrier method (c). In this example, lower and upper bounds have been added but it is not compulsory.\n\nNow the function solve() can be called with these arguments to launch a NOMAD optimization run.\n\nresult = solve(p, [3.0;3.0])\n\nWhat is returned by the solve function is a NamedTuple containing solutions and corresponding blackbox values found by the Nomad solver.","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Moustache-problem","page":"Tutorial","title":"Moustache problem","text":"beginarrayrl\n  (BB)    \n  displaystyle max_xy  x\n  st\n   y in I(x)\nendarray\n\nThe objective is to maximise f(x y) = x with f not defined outside of a tight ribbon. At a given x, the interval of the admissible y values is denoted I(x) = g(x) - varepsilon(x), g(x) + varepsilon(x), with\n\ng(x) = -(cos(x) + 01) sin(x) + 2 textand varepsilon(x) = 005 + 005 Bigg(1 + dfrac11 + x - 11Bigg)\n\n(Image: )\n\nWe can rewrite the problem such that it can be solved with NOMAD. We choose as starting point (0 2) and restrict the domain such that x in 020 and y in 0 4.\n\nbeginarrayrrcll\n  (BB)    \n  displaystyle - min_x in mathbbR^2  -x_1\n  st\n                  g(x_1) - varepsilon(x_1) - x_2  leq 0      \n                  x_2 - g(x_1) + varepsilon(x_1)  leq 0      \n          0 leq  x_1                              leq 20     \n          0 leq  x_2                              leq 4      \nendarray\n\nusing NOMAD\n\n# Objective\nfunction f(x)\n  return -x[1]\nend\n\n# Constraints\nfunction c(x)\n  g = -(abs(cos(x[1])) + 0.1) * sin(x[1]) + 2\n  ε = 0.05 + 0.05 * (1 - 1 / (1 + abs(x[1] - 11)))\n  constraints = [g - ε - x[2]; x[2] - g - ε]\n  return constraints\nend\n\n# Evaluator\nfunction bb(x)\n  bb_outputs = [f(x); c(x)]\n  success = true\n  count_eval = true\n  return (success, count_eval, bb_outputs)\nend\n\n# Define Nomad Problem\np = NomadProblem(2, 3, [\"OBJ\"; \"EB\"; \"EB\"], bb,\n                lower_bound=[0.0;0.0],\n                upper_bound=[20.0;4.0])\n\n# Fix some options\np.options.max_bb_eval = 1000 # total number of evaluations\np.options.display_stats = [\"BBE\", \"EVAL\", \"SOL\", \"OBJ\", \"CONS_H\"] # some display options\n\n# Solution\nresult = solve(p, [0.0;2.0])\nprintln(\"Optimization status: \", result.status)\nprintln(\"Solution: \", result.x_sol)\nprintln(\"is feasible: \", result.feasible)","category":"section"},{"location":"tutorial/#Linear-equality-constraints","page":"Tutorial","title":"Linear equality constraints","text":"It is also possible to define linear equality constraints in a NomadProblem structure. NOMAD handles differently these constraints and solves the original problem on a reduced subspace. For more details we refer the reader to:\n\nC. Audet, S. Le Digabel and M. Peyrega, Linear equalities in blackbox optimization. Computational Optimization and Applications, 61(1), 1-23, May 2015.\n\nWe consider the following example:\n\nbeginarrayrl\n  (BB)    \n  displaystyle min_x in mathbbR^5  (x_1 -1)^2 + (x_2 - x_3)^2 + (x_4 - x_5)^2\n  st\n   x_1 + x_2 + x_3 + x_4 + x_5 = 5 \n   x_3 -2 x_4 - 2 x_5 = -3\n   -10 leq x_1 x_2 x_3 x_4 x_5 leq 10\nendarray\n\nThis problem can be solved by Nomad the following way:\n\nusing NOMAD\n\n# blackbox\nfunction bb(x)\n  f = (x[1]- 1)^2 * (x[2] - x[3])^2 + (x[4] - x[5])^2\n  bb_outputs = [f]\n  success = true\n  count_eval = true\n  return (success, count_eval, bb_outputs)\nend\n\n# linear equality constraints\nA = [1.0 1.0 1.0 1.0 1.0;\n     0.0 0.0 1.0 -2.0 -2.0]\nb = [5.0; -3.0]\n\n# Define blackbox\np = NomadProblem(5, 1, [\"OBJ\"], # the equality constraints are not counted in the outputs of the blackbox\n                 bb,\n                 lower_bound = -10.0 * ones(5),\n                 upper_bound = 10.0 * ones(5),\n                 A = A, b = b)\n\n# Fix some options\np.options.max_bb_eval = 500\n\n# Define starting points. It must satisfy A x = b.\nx0 = [0.57186958424864897665429452899843;\n      4.9971472653643420613889247761108;\n      -1.3793445664086618762667058035731;\n      1.0403394252630473459930726676248;\n      -0.2300117084673765077695861691609]\n\n# Solution\nresult = solve(p, x0)\nprintln(\"status: \", result.status)\nprintln(\"Solution: \", result.x_sol)\nprintln(\"Satisfy Ax = b: \", A * result.x_sol ≈ b)\nprintln(\"And inside bound constraints: \", all(-10.0 .<= result.x_sol .<= 10.0))\n\nThe reader can take a look at the test folder for more complex examples.","category":"section"},{"location":"tutorial/#Trade-offs-for-computational-time-performance","page":"Tutorial","title":"Trade-offs for computational time performance","text":"The default parameters of NOMAD.jl closely follow the default parameters of the NOMAD software. More importantly, NOMAD tries to find the best solution according to the maximum budget of evaluations provided by the user.\n\nHowever, it happens that the user has a cheap blackbox in terms of computational time and needs a solution in a \"short\" amount of time. In this case, the user can remove the default quadratic model options. Generally, the computation of a given solution will be faster, (i.e. NOMAD will evaluate more points in a given amount of time) at a potential detriment of the solution quality.\n\nLet illustrate it on the following problem.\n\nusing NOMAD\n\n# Objective\nfunction f(x)\n    return sqrt((x[1]-20)^2 + (x[2]-1)^2)\nend\n\n# Constraints\nfunction c(x)\n    constraints = [sin(x[1]) - 1/10 - x[2], x[2] - sin(x[1])]\n    return constraints\nend\n\n# Evaluator\nfunction bb(x)\n    bb_outputs = [f(x); c(x)]\n    success = true\n    count_eval = true\n    return (success, count_eval, bb_outputs)\nend\n\np = NomadProblem(2, 3, [\"OBJ\"; \"PB\"; \"PB\"], bb,\n                 lower_bound=[0.0;0.0],\n                 upper_bound=[20.0;4.0])\n\n# Set some options\np.options.display_degree = 2\np.options.max_bb_eval = 1500\n\n# Default\nprintln(\"This is the default\")\n@time result_default = solve(p, [0.0;0.0])\n\n# Deactivate quadratic models\np.options.quad_model_search = false # for the search step ..\np.options.direction_type = \"ORTHO N+1 NEG\" # .. and the computation of the n+1 direction.\n\n# One can also deactivate the sorting of poll directions by quadratic models but it is not\n# mandatory as it plays a minimal role in the computational performance.\np.options.eval_queue_sort = \"DIR_LAST_SUCCESS\" \n\nprintln(\"Now with no quadratic models\")\n@time result_with_no_quad_models = solve(p, [0.0;0.0])\n\nNote that the deactivation of quadratic models allows the solver to return a solution in a shorter time.\n\nA good rule of thumb is to keep quadratic models if the blackbox possesses smoothness properties even if the derivatives are not available.\n\nFor more details about the parameters used in this section, we refer the reader to:\n\nC. Audet, A. Ianni, S. Le Digabel and C. Tribes, Reducing the number of function evaluations in mesh adaptive direct search algorithms, SIAM Journal on Optimization, 24(2), 621-642, 2014.","category":"section"},{"location":"tutorial/#Multiobjective-optimization","page":"Tutorial","title":"Multiobjective optimization","text":"NOMAD.jl can solve multiobjective optimization problems of the form:\n\nbeginarrayrl\n  (MBB)   \n  displaystyle min_x in mathbbR^n  f(x) = left(f_1(x) f_2(x) ldots f_m(x)right)^top\n  st\n   c(x) leq 0 \n   lb leq x leq ub \nendarray\n\nwhere m geq 2 is the number of objectives.\n\nUnlike single-objective optimization, the set of solutions to such a problem is generally not a singleton. It is composed of several solutions whose objective values represent the best trade-offs that the algorithm may achieve at the end of the optimization.\n\nNOMAD.jl switches to multiobjective mode when a NomadProblem is given more than one objective OBJ as parameter. However, NOMAD.jl only supports up to 5 objectives. Keep in mind that the larger the number of objectives, the more difficult the problem is to solve.\n\nFinally, the multiobjective mode of NOMAD.jl does not support certain options available in single-objective optimization. Specifically, in multiobjective optimization, NOMAD.jl deactivates all search strategies except the speculative search, the NM search and the Quadratic model search. The default eval_sort_type and direction_type options are switched to \"DIR_LAST_SUCCESS\" and \"ORTHO N+1 QUAD\", respectively.\n\nWe consider the following example, the optimal design of a welded beam.\n\nbeginarrayrl\n  (WB)   \n  displaystyle min_x = (h l t b) in mathbbR^4  left(110471 h^2 l + 004811 t b (140 + l) dfrac21952t^3 bright)^top \n  st\n   c_1(x) = tau(x) - 13600 leq 0  \n   c_2(x) = sigma(x) - 30000 leq 0\n   c_3(x) = h - b leq 0\n   c_4(x) = 6000 - P_c(x) leq 0\n   h b in 0125 5 l t in 01 10\nendarray\n\nwhere h l t b are the four design parameters to optimize.\n\nThe following equations describe the physics constraints of the system (stress and buckling terms):\n\nbeginarrayrl\n  tau(x)  = sqrt(tau)^2 + (tau)^2 + dfracl tau tausqrt025 (l^2 + (h + t)^2))  \n  tau  = dfrac6000sqrt2 h l  \n  tau  = dfrac6000 (14 + 05 l) sqrt025 (l^2 + (h + t)^2))2 left(0707 h l (l^212 + 025 (h + t)^2)right)\n  sigma(x)  = dfrac504000t^2 b\n  P_c(x)  = 64746022 (1 - 00282346 t) t b^3\nendarray\n\nf_1\n\ncorresponds to the construction costs and f_2 the end deflection (which corresponds to rigidity) of the beam. Both must be minimized.\n\nusing NOMAD\n\n# blackbox\nfunction welded_beam(x)\n    # Variables\n    h = x[1]\n    l = x[2]\n    t = x[3]\n    b = x[4]\n\n    # Objectives\n    f1 = 1.10471 * h^2 * l + 0.04811 * t * b * (14.0 + l)\n    f2 = 2.1952 / (t^3 * b)\n\n    # Physics equations\n    tau_p = 6000.0 / (sqrt(2) * h * l)\n    tau_pp = 6000 * (14 + 0.5 * l) * sqrt(0.25 * (l^2 + (h + t)^2))\n    tau_pp /= (2 * (0.707 * h * l * (l^2 / 12.0 + 0.25 * (h + t)^2)))\n    tau = sqrt(tau_p^2 + tau_pp^2 + l * tau_p * tau_pp / sqrt(0.25 * (l^2 + (h + t)^2)))\n    sigma = 504000 / (t^2 * b)\n    Pc = 64746.022 * (1 - 0.0282346 * t) * t * b^3\n\n    # Constraints\n    c1 = tau - 13600\n    c2 = sigma - 30000\n    c3 = h - b\n    c4 = 6000 - Pc\n\n    bb_outputs = [f1, f2, c1, c2, c3, c4]\n    success = true\n    count_eval = true\n    return (success, count_eval, bb_outputs)\nend\n\n# Define the problem\nlb = [0.125, 0.1, 0.1, 0.125]\nub = [5.0, 10.0, 10.0, 5.0]\npb = NomadProblem(4, 6, [\"OBJ\", \"OBJ\", \"PB\", \"PB\", \"PB\", \"PB\"],\n                  welded_beam,\n                  lower_bound=[0.125, 0.1, 0.1, 0.125],\n                  upper_bound=[5.0, 10.0, 10.0, 5.0])\n\n# Set some options\npb.options.display_degree = 2\npb.options.max_bb_eval = 1500\n\n# As for the single-objective case, you could deactivate this\n# option to go faster, but the performance may be worse\n# pb.options.quad_model_search = false\n\n# Start from a middle box point\nresult = solve(pb, (lb + ub) / 2)\n\n# The solution set is returned as a matrix of dimensions n x nb_solutions,\n# where n is the dimension of the problem.\nprintln(\"Optimization status: \", result.status)\nprintln(\"The algorithm has found \", size(result.x_sol, 2), \" solutions:\")\nfor (ind, (x, bbo)) in enumerate(zip(eachcol(result.x_sol), eachcol(result.bbo_sol)))\n  println(\"Solution \", ind, \": \", x,\n          \"; f(x) = \", bbo[1:2],\n          \"; c(x) = \", bbo[3:end])\nend\nprintln(\"They are \", result.feasible ? \"feasible\" : \"infeasible\")\n\n# In multiobjective optimization, it can be interesting to see the\n# set of trade-offs in the objective space\nusing Plots\nfig = scatter(result.bbo_sol[1, :], result.bbo_sol[2, :],\n              xlabel=\"Cost\", ylabel=\"Deflection\",\n              title=\"Pareto front approximation\")\n\nFor more information about the multiobjective algorithm (DMulti-MADS), please refer to the following articles:\n\nJ. Bigeon, S. Le Digabel, & L. Salomon, DMulti-MADS: Mesh adaptive direct multisearch for bound-constrained  blackbox multiobjective optimization, Computational Optimization and Applications, 79(2), 301-338, 2021.\n\nJ. Bigeon, S. Le Digabel, & L. Salomon, Handling of constraints in multiobjective blackbox optimization,  Computational Optimization and Applications, 89(1), 69-113, 2024.\n\nS. Le Digabel, A. Lesage-Landry, L. Salomon, & C. Tribes (2025),  Efficient search strategies for constrained multiobjective blackbox optimization,  arXiv preprint arXiv:2504.02986., 2025.\n\nThe problem is taken from:\n\nK. Deb, Evolutionary algorithms for multi-criterion optimization in engineering design,  Evolutionary algorithms in engineering and computer science, 2, 135-161, (1999)","category":"section"}]
}
